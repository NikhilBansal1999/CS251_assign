 How did you find your way back into functional programming research?\n\n Now I had a job as a lecturer and my boss, my Head of Department said to me, \"Well Simon, I'll give you a light teaching load so you can get your research started.\" But of course I had not been a PhD student so I had no idea how to do research. I would sit there in my office with a blank sheet of paper and a sharp pencil and wait for great ideas to come. Of course, nothing did. Then an undergraduate would knock at the door and say, \"Simon, do you have a moment?\" I'd welcome them in as a distraction from this difficult business of doing research.\n\nEventually one of my colleagues, a really good guy, called John Washbrook, said to me, \"Simon, you should just get on and do something no matter how humble and simple.\" In the end the first thing that I did was I wrote a parser generator for a functional language SASL, so it was a bit like Yacc. I called it \8220Yacc in SASL.\8221 That got published in 1985 in Software Practice and Experience.\n\nAt the time, I was very inspired by David Turner's papers about SK combinators. I was in London, he was in Canterbury, so I asked him to be an informal mentor. Since I didn't have an adviser he was my sort of remote advisor. I would go to see him every few months and we would have a chat over coffee. That was incredibly helpful to me because I did feel a bit uncertain about what to do.\n How did you decide that functional programming was what you wanted to do research on?\n\n That was at Cambridge while I was getting my Diploma. There was a very eccentric professor there called Arthur Norman and he was big on computer algebra at the time. He gave a short series of lectures about functional programming, which I had never heard of, in which he showed some functional programs. He even built things like circular lists, which didn't seem even possible given you don't have any side effects. The second thing was David Turner's papers about SK combinators and the amazing idea that you could take lambda expressions and translate them into this big mess of S's and K's and it would evaluate to the same thing.\n\nAnd all of that occurred at the same time that John Backus was winning the Turing Award and giving his talk called \8220Can Programming Be Liberated From the von Neumann Style?\" In his talk he introduced FP, his functional programming language, and cast it in a big picture. He said, \"This is the way to write programs, and moreover not only will it revolutionize programming but we should even build new computers to execute these programs.\" This was a call to action. We already thought functional programming was cool, but here was this extremely famous guy saying \"It's not only cool it's the Right Thing to do.\" There were a bunch of people at Cambridge, John Hughes, Thomas Clarke, Jon Fairbairn, myself, and a few others who all got excited about functional programming at the same time. It was one of those coincidental things. We all just caught fire.\n\n What were the big open problems in functional programming when you were getting into it?\n\n Functional programming is a radical and elegant attack on the whole enterprise of writing programs. It's very different from the \"do this and then do that\8221 programming mentality. You have to rewire your brain in quite a different way. For a long time it was well understood theoretically\8212there was lots of stuff about semantics and it had these very deep foundations in logic. But in terms of a practical programming medium it seemed like a completely virgin field. Then with David Turner\8217s work, and with the whole ML effort at Edinburgh, people suddenly started to say, \"Actually, these languages could be not just elegant, and beautiful, and mathematically cool\8212but also useful. You might actually be able to write interesting programs using them.\" That was the movement that I got involved in.\n\n I wanted to talk about how Haskell came about.\n\n In the late 80's there were a number of separate researchers who were doing stuff with lazy functional programming. I was one, John Hughes was another, Paul Hudak was another, Thomas Johnsson and Lennart Augustsson at Gothenburg, Arvind and his dataflow colleagues at MIT, Joe Fasel Los Alamos was another, Rinus Plasmeijer at Nijmegen, and so on. There were maybe a dozen all together.\n\nWe would meet each other at conferences and we came to realize that we were all building little programming languages and they all basically looked the same. We thought, \"Oh, we should do something very modest, very humble. We should just agree a common syntax so that we can run each other's programs.\" We had SASL and Miranda, David Turner's languages for guidance, so we thought we'll just cohere around some syntactic least common denominator. We wanted a basis for teaching and research just to avoid unnecessary diversity. We weren't thinking of Haskell as a way to solve research problems at all, more as a substrate for research.\n\nWe met and decided, \"We should form a committee and design a language.\" So we did, and we then physically met in person. This wasn't before email, but it was certainly before the web and collaborative working and so-forth. We physically met on several occasions to design the language. The surprising thing is that it turned into a research project.\n How did that come about?\n\nSeveral things that happened that were quite serendipitous and unexpected. We knew it was going to be lazy, we knew it was going to have parametric polymorphism like ML does, and we knew it would have algebraic data types and pattern matching. That was all part of the consensus of what we were starting from. Type classes, on the other hand, were entirely new.\nWe had spent some time debating what we were going to do about functions like read, show, serialization, and equality. They're not parametrically polymorphic, but they are a bit polymorphic, because they should work on a lot of types. And then, out of the blue, Phil Wadler and his student Steve Blott produced, fully formed, the idea of type classes. I still have the email which he sent: it was almost like a little paper to the then committee. We were bowled over: \"Oh, this is how we could deal with all of those awkward problems.\" At that stage, we had a choice make. We could keep thinking of Haskell embodying a current consensus, as we had been. But we didn\8217t do that. Instead we said, \"Type classes may be new, but they solve a really nasty, awkward problem that's a wart on the face of our beautiful language. Let\8217s embrace them.\" So we incorporated type classes wholeheartedly, and they turned out to be one of Haskell's big contributions to the world.\n\nFor reasons like this\8212monadic I/O is another example\8212Haskell ended up being significantly more innovative and ambitious that we had originally intended. But that was largely accidental.\n\n What was the biggest surprise about putting Haskell out there?\n\n I had always assumed that the more bleeding edge changes to the type system, things like type-level functions, generalized algebraic data types (GADTs), higher rank polymorphism, and existential data types, would be picked up and used enthusiastically by PhD students in search of a topic, but not really used much in industry. But in fact it turns out that people in companies are using some of these still-not-terribly-stable extensions. I think it's because people in companies are writing software that they want to still be able to maintain and modify in five years time. As you scale up, and as your ambition about timescale increases, so maybe you'll invest more in the static guarantees you get from a type system, and then you push the type system harder. You see people out in industry writing blog posts about catamorphisms and categorical connections, and plenty of stuff that I don't understand. Somehow, the level of abstraction offered by a sophisticated type system lets you get much more ambitious in terms of the intellectual complexity of what you can deal with.\n\n As you were doing all of this work, what was the relationship of the functional programming work to what other people were interested in at POPL at the time?\n\n Initially I always thought of POPL as being a conference that was for people cleverer than me, so it was quite a while before I even submitted a paper to POPL. But when I did I found a community that was completely aligned with the kind of things that I cared about. It's right there in the title isn't it? Principles of Programming Languages, so it cares about being principled and it cares about elegance and economy of effort. Try to get the job done with as little machinery as possible. Indeed, I feel that most of my research life is about saying, \"It has to be simpler.\"\n\nI always felt I was more of a theory user, not a theory developer, whereas I'm a compiler developer, not just a compiler user. So I always felt slightly out of my class at POPL. I still do.\n\n What is an important problem our community can work on solving in the next five or ten years?\n\n Education. If we're to get the principles, and elegance, and modularity, and economy of effort, and abstractions that POPL contributors value so highly, if we are to get them actually part of the fabric of the software that holds our digital lives together, the way to do that is by instilling those values into our undergraduates, and so then they will become the developers of the future, and CTO's of startups. So, there's a big inertia to overcome, but over time it'll happen. As I often say, when the limestone of imperative programming has worn away, the granite of functional programming will be revealed underneath
